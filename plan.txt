# Цель проекта

Создать демонстрационный pet-project «Marketplace услуг репетиторов», позволяющий показать навыки strong middle frontend-разработчика и уверенный backend-стек.

## Стек технологий

### Frontend
- **Next.js 15.5.x LTS** (App Router, React Server Components)
- **React 19.x**
- **TypeScript 5.x**
- **Tailwind CSS 4.1.x** (CSS-first конфигурация)
- **shadcn/ui** (компоненты поверх Radix UI)
- **@tanstack/react-query 5.90.x** (серверное состояние)
- **@tanstack/react-table 8.x** (таблицы)
- **React Hook Form 7.61.x + @hookform/resolvers 5.2.x**
- **Zod 4.x** (валидация)
- **Zustand 5.x** (клиентское состояние)
- **Motion 12.x** (анимации, ex. Framer Motion)
- **nuqs 2.x** (type-safe URL query params)

### Backend
- **Django 5.2 LTS**
- **Django REST Framework 3.15.x**
- **drf-spectacular 0.29.x** (OpenAPI 3.1)
- **Django Channels 4.3.x** (WebSockets)
- **channels-redis 5.x**
- **Celery 5.4.x** (фоновые задачи)
- **Python 3.12+**

### Инфраструктура
- **Docker Compose** (единый монорепо)
- **PostgreSQL 17** + **pgvector** (векторный поиск)
- **Redis 7.4** (кеш, channels layer, Celery broker)
- **MinIO** (S3-compatible storage)
- **OpenSearch 2.x** (полнотекстовый поиск)
- **Unleash 7.x** (feature flags)

### Тестирование
- **Vitest 4.x + @testing-library/react 16.x** (frontend)
- **MSW 2.12.x** (API mocking)
- **pytest 8.x + pytest-django 4.9.x + factory-boy 3.3.x** (backend)

### Генерация типов
- **orval 7.17.x** (OpenAPI → TypeScript + TanStack Query хуки)

---

# Описание проекта

Платформа, где студенты (ученики) могут искать и нанимать репетиторов по предметам/уровням/формату занятий, фильтровать и сортировать результаты, просматривать подробные профильные карточки, заполнять и редактировать расширенные профили репетиторов (wizard), бронировать занятия через календарь, общаться в реальном времени (чат), оплачивать занятия через mock-платёжную систему, искать репетиторов через полнотекстовый и семантический поиск и участвовать в A/B тестировании интерфейсов через feature flags.

Проект разворачивается полностью в Docker Compose, покрывается автоматическими тестами (FE/BE), CI запускает тесты и генерацию типов, а OpenAPI-схема обеспечивает строгие контракты между фронтом и бэком.

---

# Структура монорепо

```
/
├── frontend/                 # Next.js приложение
│   ├── src/
│   │   ├── app/             # App Router pages
│   │   ├── components/      # React компоненты
│   │   │   ├── ui/          # UI-kit (shadcn/ui based)
│   │   │   ├── features/    # Feature-specific компоненты
│   │   │   └── layouts/     # Layout компоненты
│   │   ├── hooks/           # Custom hooks
│   │   ├── lib/             # Утилиты, API client
│   │   ├── stores/          # Zustand stores
│   │   ├── types/           # TypeScript типы
│   │   └── generated/       # Сгенерированные orval типы и хуки
│   ├── public/
│   ├── tests/
│   ├── package.json
│   └── orval.config.ts
├── backend/                  # Django приложение
│   ├── config/              # Django settings, urls, asgi/wsgi
│   ├── apps/
│   │   ├── core/            # Базовые модели (User)
│   │   ├── tutors/          # Репетиторы
│   │   ├── students/        # Ученики
│   │   ├── bookings/        # Бронирования
│   │   ├── chat/            # Чат (Channels)
│   │   ├── payments/        # Mock платежи
│   │   └── search/          # OpenSearch интеграция
│   ├── tests/
│   ├── requirements/
│   │   ├── base.txt
│   │   ├── dev.txt
│   │   └── prod.txt
│   └── manage.py
├── docker/
│   ├── frontend/
│   │   └── Dockerfile
│   ├── backend/
│   │   └── Dockerfile
│   └── nginx/
│       └── nginx.conf
├── docker-compose.yml
├── docker-compose.prod.yml
├── .github/
│   └── workflows/
│       ├── ci.yml
│       └── deploy.yml
├── .env.example
├── README.md
└── docs/
    └── UI_KIT.md            # Документация UI-kit
```

---

# Итерации проекта

## Итерация 0 — Инфраструктура и DevEx

**Цель:** настроить удобную среду разработки с автоматизацией.

**Что делаем:**

1. Инициализация Git репозитория:
   - `.gitignore` (Python, Node, IDE, env files)
   - `LICENSE` (MIT)
   - `README.md` с инструкциями

2. Настройка линтеров и форматтеров:
   - Frontend: **Biome** (быстрая замена ESLint + Prettier)
   - Backend: **Ruff** (быстрый линтер/форматтер Python)
   - Pre-commit hooks: **husky + lint-staged** (frontend), **pre-commit** (backend)

3. `.env.example` с документированными переменными:
   ```env
   # Database
   POSTGRES_DB=tutors
   POSTGRES_USER=tutors
   POSTGRES_PASSWORD=secret
   DATABASE_URL=postgresql://tutors:secret@db:5432/tutors

   # Redis
   REDIS_URL=redis://redis:6379/0

   # Django
   DJANGO_SECRET_KEY=change-me
   DJANGO_DEBUG=true
   DJANGO_ALLOWED_HOSTS=localhost,127.0.0.1

   # Frontend
   NEXT_PUBLIC_API_URL=http://localhost:8000/api
   ```

4. GitHub Actions CI (`.github/workflows/ci.yml`):
   - Matrix: lint → typecheck → test → build
   - Параллельные jobs для frontend и backend
   - Кеширование зависимостей (npm, pip)

**Acceptance Criteria:**
- [ ] `git clone && docker compose up` запускает всё окружение
- [ ] Pre-commit hooks блокируют невалидный код
- [ ] CI проходит на пустом проекте

---

## Итерация 1 — Базовый каркас проекта + Docker Compose

**Цель:** собрать фундамент FE/BE, обеспечить reproducible dev environment, подключить тесты.

**Что делаем:**

1. **Docker Compose** (`docker-compose.yml`):
   ```yaml
   services:
     frontend:
       build: ./docker/frontend
       ports: ["3000:3000"]
       volumes: ["./frontend:/app"]
       environment:
         - NEXT_PUBLIC_API_URL=http://localhost:8000/api
       depends_on: [backend]

     backend:
       build: ./docker/backend
       ports: ["8000:8000"]
       volumes: ["./backend:/app"]
       environment:
         - DATABASE_URL=postgresql://tutors:secret@db:5432/tutors
         - REDIS_URL=redis://redis:6379/0
       depends_on: [db, redis]

     db:
       image: postgres:17-alpine
       volumes: ["postgres_data:/var/lib/postgresql/data"]
       environment:
         POSTGRES_DB: tutors
         POSTGRES_USER: tutors
         POSTGRES_PASSWORD: secret

     redis:
       image: redis:7.4-alpine
       volumes: ["redis_data:/data"]

     minio:
       image: minio/minio:latest
       command: server /data --console-address ":9001"
       ports: ["9000:9000", "9001:9001"]
       volumes: ["minio_data:/data"]
       environment:
         MINIO_ROOT_USER: minioadmin
         MINIO_ROOT_PASSWORD: minioadmin

   volumes:
     postgres_data:
     redis_data:
     minio_data:
   ```

2. **Frontend инициализация:**
   ```bash
   npx create-next-app@latest frontend --typescript --tailwind --app --src-dir
   cd frontend
   npx shadcn@latest init
   npx shadcn@latest add button card input
   ```

   Настройка Tailwind v4 (CSS-first):
   ```css
   /* app/globals.css */
   @import "tailwindcss";

   @theme {
     --color-primary: oklch(0.7 0.15 250);
     --color-secondary: oklch(0.6 0.1 200);
     --radius-default: 0.5rem;
     --font-sans: "Inter", system-ui, sans-serif;
   }
   ```

3. **Backend инициализация:**
   ```bash
   django-admin startproject config backend
   cd backend
   python manage.py startapp core
   python manage.py startapp tutors
   ```

   Модели (`apps/core/models.py`):
   ```python
   from django.contrib.auth.models import AbstractUser
   from django.db import models

   class User(AbstractUser):
       USER_TYPE_CHOICES = [
           ('student', 'Student'),
           ('tutor', 'Tutor'),
       ]
       user_type = models.CharField(max_length=10, choices=USER_TYPE_CHOICES)
       avatar = models.URLField(blank=True)
       phone = models.CharField(max_length=20, blank=True)
   ```

   Модель Tutor (`apps/tutors/models.py`):
   ```python
   class Tutor(models.Model):
       user = models.OneToOneField(User, on_delete=models.CASCADE)
       headline = models.CharField(max_length=200)
       bio = models.TextField()
       hourly_rate = models.DecimalField(max_digits=10, decimal_places=2)
       subjects = models.JSONField(default=list)  # ["math", "physics"]
       is_verified = models.BooleanField(default=False)
       created_at = models.DateTimeField(auto_now_add=True)
       updated_at = models.DateTimeField(auto_now=True)
   ```

4. **Первый DRF endpoint** (`apps/tutors/views.py`):
   ```python
   from rest_framework import viewsets
   from .models import Tutor
   from .serializers import TutorSerializer

   class TutorViewSet(viewsets.ReadOnlyModelViewSet):
       queryset = Tutor.objects.select_related('user').all()
       serializer_class = TutorSerializer
   ```

5. **Frontend: базовый layout и fetch:**
   ```tsx
   // app/tutors/page.tsx
   async function getTutors() {
     const res = await fetch(`${process.env.NEXT_PUBLIC_API_URL}/tutors/`);
     return res.json();
   }

   export default async function TutorsPage() {
     const tutors = await getTutors();
     return (
       <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
         {tutors.map((tutor) => (
           <TutorCard key={tutor.id} tutor={tutor} />
         ))}
       </div>
     );
   }
   ```

6. **Тестовая инфраструктура:**

   Backend (`pytest.ini`):
   ```ini
   [pytest]
   DJANGO_SETTINGS_MODULE = config.settings
   python_files = test_*.py
   addopts = -v --tb=short
   ```

   Frontend (`vitest.config.ts`):
   ```typescript
   import { defineConfig } from 'vitest/config';
   import react from '@vitejs/plugin-react';

   export default defineConfig({
     plugins: [react()],
     test: {
       environment: 'jsdom',
       setupFiles: ['./tests/setup.ts'],
     },
   });
   ```

7. **Seed data** (`backend/apps/tutors/management/commands/seed.py`):
   - Создаёт 20 тестовых репетиторов с faker

**Acceptance Criteria:**
- [ ] `docker compose up` запускает все сервисы
- [ ] `GET /api/tutors/` возвращает список репетиторов
- [ ] Frontend отображает карточки репетиторов
- [ ] `pytest` проходит (минимум 1 тест модели, 1 тест API)
- [ ] `npm test` проходит (минимум 1 тест компонента)

---

## Итерация 2 — OpenAPI + автогенерация TypeScript типов (orval)

**Цель:** строгая контрактная интеграция FE/BE через OpenAPI схему.

**Что делаем:**

1. **drf-spectacular** настройка:
   ```python
   # config/settings.py
   INSTALLED_APPS += ['drf_spectacular']

   REST_FRAMEWORK = {
       'DEFAULT_SCHEMA_CLASS': 'drf_spectacular.openapi.AutoSchema',
   }

   SPECTACULAR_SETTINGS = {
       'TITLE': 'Tutors Marketplace API',
       'VERSION': '1.0.0',
       'SERVE_INCLUDE_SCHEMA': False,
       'COMPONENT_SPLIT_REQUEST': True,
       'SCHEMA_PATH_PREFIX': r'/api/',
   }
   ```

   URLs:
   ```python
   # config/urls.py
   from drf_spectacular.views import SpectacularAPIView, SpectacularSwaggerView

   urlpatterns = [
       path('api/schema/', SpectacularAPIView.as_view(), name='schema'),
       path('api/docs/', SpectacularSwaggerView.as_view(url_name='schema')),
   ]
   ```

2. **Расширенные сериалайзеры** с документацией:
   ```python
   from drf_spectacular.utils import extend_schema_field
   from drf_spectacular.types import OpenApiTypes

   class TutorSerializer(serializers.ModelSerializer):
       full_name = serializers.SerializerMethodField()

       @extend_schema_field(OpenApiTypes.STR)
       def get_full_name(self, obj):
           return f"{obj.user.first_name} {obj.user.last_name}"

       class Meta:
           model = Tutor
           fields = ['id', 'full_name', 'headline', 'bio', 'hourly_rate', 'subjects']
   ```

3. **orval** конфигурация (`frontend/orval.config.ts`):
   ```typescript
   import { defineConfig } from 'orval';

   export default defineConfig({
     tutors: {
       input: 'http://localhost:8000/api/schema/',
       output: {
         mode: 'tags-split',
         target: './src/generated/api',
         schemas: './src/generated/schemas',
         client: 'react-query',
         httpClient: 'fetch',
         override: {
           mutator: {
             path: './src/lib/api-client.ts',
             name: 'customFetch',
           },
           query: {
             useQuery: true,
             useMutation: true,
             signal: true,
           },
         },
       },
     },
   });
   ```

4. **npm scripts:**
   ```json
   {
     "scripts": {
       "generate:api": "orval",
       "generate:api:check": "orval --check"
     }
   }
   ```

5. **Использование сгенерированных хуков:**
   ```tsx
   // Было (ad-hoc)
   const { data } = useQuery(['tutors'], () => fetch('/api/tutors/'));

   // Стало (типизировано)
   import { useGetTutorsList } from '@/generated/api/tutors';

   const { data: tutors, isLoading } = useGetTutorsList();
   // tutors имеет тип TutorSerializer[] | undefined
   ```

6. **CI проверка актуальности типов:**
   ```yaml
   - name: Check generated types
     run: |
       cd frontend
       npm run generate:api
       git diff --exit-code src/generated/
   ```

**Acceptance Criteria:**
- [ ] `/api/docs/` показывает Swagger UI
- [ ] `/api/schema/` отдаёт валидный OpenAPI 3.1
- [ ] `npm run generate:api` генерирует типы и хуки
- [ ] Компоненты используют сгенерированные типы
- [ ] CI падает если типы не актуальны

---

## Итерация 3 — UI-kit + дизайн-система + Motion

**Цель:** создать переиспользуемый UI-kit с документацией.

**Перенесена раньше (была итерация 5), чтобы wizard использовал готовый UI-kit.**

**Что делаем:**

1. **Дизайн-токены** в Tailwind v4 (`globals.css`):
   ```css
   @theme {
     /* Colors */
     --color-primary-50: oklch(0.97 0.02 250);
     --color-primary-500: oklch(0.55 0.15 250);
     --color-primary-600: oklch(0.45 0.15 250);

     --color-success: oklch(0.65 0.15 145);
     --color-warning: oklch(0.75 0.15 85);
     --color-error: oklch(0.55 0.2 25);

     /* Spacing */
     --spacing-page: 1.5rem;
     --spacing-section: 2rem;

     /* Shadows */
     --shadow-card: 0 2px 8px oklch(0 0 0 / 0.08);
     --shadow-dropdown: 0 4px 16px oklch(0 0 0 / 0.12);

     /* Motion */
     --ease-out-expo: cubic-bezier(0.16, 1, 0.3, 1);
     --duration-fast: 150ms;
     --duration-normal: 250ms;
   }
   ```

2. **Компоненты UI-kit** (`components/ui/`):
   - `Button` — варианты: primary, secondary, ghost, destructive; размеры: sm, md, lg
   - `Input` — с лейблом, ошибкой, иконками
   - `Select` — на базе Radix Select
   - `Modal` / `Dialog` — на базе Radix Dialog
   - `Card` — контейнер с shadow и padding
   - `Avatar` — с fallback initials
   - `Badge` — статусы, теги
   - `Skeleton` — loading placeholder
   - `Toast` — уведомления (sonner)

3. **Motion интеграция:**
   ```tsx
   // components/ui/animated-card.tsx
   import { motion } from 'motion/react';

   export function AnimatedCard({ children }: { children: React.ReactNode }) {
     return (
       <motion.div
         initial={{ opacity: 0, y: 20 }}
         animate={{ opacity: 1, y: 0 }}
         exit={{ opacity: 0, y: -20 }}
         transition={{ duration: 0.25, ease: [0.16, 1, 0.3, 1] }}
         className="rounded-lg border bg-card p-4 shadow-card"
       >
         {children}
       </motion.div>
     );
   }
   ```

4. **Документация UI-kit** (`docs/UI_KIT.md`):
   ```markdown
   # UI Kit Documentation

   ## Button

   ### Usage
   \`\`\`tsx
   import { Button } from '@/components/ui/button';

   <Button variant="primary" size="md">Click me</Button>
   \`\`\`

   ### Variants
   | Variant | Use case |
   |---------|----------|
   | primary | Main actions (submit, save) |
   | secondary | Secondary actions |
   | ghost | Tertiary actions, icon buttons |
   | destructive | Dangerous actions (delete) |

   ### Props
   - `variant`: 'primary' | 'secondary' | 'ghost' | 'destructive'
   - `size`: 'sm' | 'md' | 'lg'
   - `isLoading`: boolean
   - `leftIcon`: ReactNode
   - `rightIcon`: ReactNode
   ```

5. **Тесты компонентов:**
   ```typescript
   // tests/components/button.test.tsx
   import { render, screen } from '@testing-library/react';
   import { Button } from '@/components/ui/button';

   describe('Button', () => {
     it('renders with text', () => {
       render(<Button>Click me</Button>);
       expect(screen.getByRole('button')).toHaveTextContent('Click me');
     });

     it('shows loading state', () => {
       render(<Button isLoading>Submit</Button>);
       expect(screen.getByRole('button')).toBeDisabled();
     });
   });
   ```

**Acceptance Criteria:**
- [ ] Все базовые компоненты созданы и работают
- [ ] Motion анимации плавные (60fps)
- [ ] `docs/UI_KIT.md` содержит документацию всех компонентов
- [ ] Тесты компонентов проходят

---

## Итерация 4 — Сложная форма профиля репетитора (Wizard)

**Цель:** показать работу со сложными динамическими формами.

**Что делаем:**

1. **Wizard структура** (5 шагов):
   ```
   Step 1: Личные данные (имя, фото, телефон, bio)
   Step 2: Предметы и уровни (динамический список)
   Step 3: Цены и форматы (онлайн/оффлайн, групповые/индивидуальные)
   Step 4: Локации (город, район, готовность выезжать)
   Step 5: Расписание (availability calendar)
   ```

2. **Zod схемы** (`lib/schemas/tutor-profile.ts`):
   ```typescript
   import { z } from 'zod/v4';

   export const personalInfoSchema = z.object({
     firstName: z.string().min(2, 'Минимум 2 символа'),
     lastName: z.string().min(2, 'Минимум 2 символа'),
     phone: z.string().regex(/^\+?[0-9]{10,15}$/, 'Неверный формат'),
     bio: z.string().min(50, 'Минимум 50 символов').max(1000),
     avatarUrl: z.string().url().optional(),
   });

   export const subjectSchema = z.object({
     name: z.string().min(1),
     level: z.enum(['beginner', 'intermediate', 'advanced', 'expert']),
     hourlyRate: z.number().min(0),
   });

   export const subjectsStepSchema = z.object({
     subjects: z.array(subjectSchema).min(1, 'Добавьте хотя бы один предмет'),
   });

   // ... остальные шаги

   export const tutorProfileSchema = personalInfoSchema
     .merge(subjectsStepSchema)
     .merge(pricingSchema)
     .merge(locationSchema)
     .merge(availabilitySchema);
   ```

3. **Multi-step form с RHF:**
   ```tsx
   // components/tutor-wizard/wizard-provider.tsx
   import { FormProvider, useForm } from 'react-hook-form';
   import { zodResolver } from '@hookform/resolvers/zod';

   export function WizardProvider({ children }: { children: React.ReactNode }) {
     const methods = useForm({
       resolver: zodResolver(tutorProfileSchema),
       mode: 'onChange',
       defaultValues: loadDraftFromStorage(),
     });

     // Автосохранение в localStorage
     useEffect(() => {
       const subscription = methods.watch((data) => {
         saveDraftToStorage(data);
       });
       return () => subscription.unsubscribe();
     }, [methods]);

     return <FormProvider {...methods}>{children}</FormProvider>;
   }
   ```

4. **Динамические поля (useFieldArray):**
   ```tsx
   // components/tutor-wizard/subjects-step.tsx
   import { useFieldArray, useFormContext } from 'react-hook-form';

   export function SubjectsStep() {
     const { control } = useFormContext();
     const { fields, append, remove } = useFieldArray({
       control,
       name: 'subjects',
     });

     return (
       <div className="space-y-4">
         {fields.map((field, index) => (
           <motion.div
             key={field.id}
             initial={{ opacity: 0, height: 0 }}
             animate={{ opacity: 1, height: 'auto' }}
             exit={{ opacity: 0, height: 0 }}
           >
             <SubjectFields index={index} onRemove={() => remove(index)} />
           </motion.div>
         ))}
         <Button variant="ghost" onClick={() => append({ name: '', level: 'beginner', hourlyRate: 0 })}>
           + Добавить предмет
         </Button>
       </div>
     );
   }
   ```

5. **File upload на MinIO:**
   ```python
   # backend/apps/core/views.py
   import boto3
   from django.conf import settings

   class FileUploadView(APIView):
       parser_classes = [MultiPartParser]

       def post(self, request):
           file = request.FILES['file']
           s3 = boto3.client('s3',
               endpoint_url=settings.MINIO_ENDPOINT,
               aws_access_key_id=settings.MINIO_ACCESS_KEY,
               aws_secret_access_key=settings.MINIO_SECRET_KEY,
           )
           key = f"avatars/{uuid.uuid4()}/{file.name}"
           s3.upload_fileobj(file, settings.MINIO_BUCKET, key)
           url = f"{settings.MINIO_PUBLIC_URL}/{settings.MINIO_BUCKET}/{key}"
           return Response({'url': url})
   ```

6. **Draft API** для сохранения прогресса:
   ```python
   class TutorDraftViewSet(viewsets.ModelViewSet):
       serializer_class = TutorDraftSerializer

       def get_queryset(self):
           return TutorDraft.objects.filter(user=self.request.user)
   ```

7. **Тесты:**
   - Unit-тесты Zod схем
   - Интеграционные тесты формы с MSW
   - Backend тесты сериалайзеров

**Acceptance Criteria:**
- [ ] Wizard работает на 5 шагах
- [ ] Валидация работает на каждом шаге
- [ ] Данные сохраняются в localStorage
- [ ] Файлы загружаются в MinIO
- [ ] Draft сохраняется на backend
- [ ] Динамические поля (subjects) добавляются/удаляются с анимацией

---

## Итерация 5 — Каталог репетиторов: фильтры, SSR, таблицы

**Цель:** реализовать UI для поиска/фильтрации с оптимальным UX.

**Что делаем:**

1. **Страница каталога** (`/tutors`):
   - Поисковая строка с debounce (300ms)
   - Фильтры: предмет, цена (range), рейтинг, формат, локация
   - Сортировка: по рейтингу, цене, новизне
   - Grid/List переключатель

2. **Type-safe URL params** с nuqs:
   ```tsx
   // app/tutors/search-params.ts
   import { parseAsString, parseAsInteger, createSearchParamsCache } from 'nuqs/server';

   export const searchParamsCache = createSearchParamsCache({
     q: parseAsString.withDefault(''),
     subject: parseAsString,
     minPrice: parseAsInteger,
     maxPrice: parseAsInteger,
     format: parseAsString,
     sort: parseAsString.withDefault('rating'),
     page: parseAsInteger.withDefault(1),
   });
   ```

3. **Server Component с prefetch:**
   ```tsx
   // app/tutors/page.tsx
   import { searchParamsCache } from './search-params';
   import { getTutors } from '@/lib/api/tutors';

   export default async function TutorsPage({
     searchParams,
   }: {
     searchParams: Promise<Record<string, string>>;
   }) {
     const params = await searchParamsCache.parse(searchParams);
     const tutors = await getTutors(params);

     return (
       <Suspense fallback={<TutorGridSkeleton />}>
         <TutorFilters />
         <TutorGrid tutors={tutors} />
       </Suspense>
     );
   }
   ```

4. **Backend фильтрация:**
   ```python
   # apps/tutors/filters.py
   import django_filters

   class TutorFilter(django_filters.FilterSet):
       min_price = django_filters.NumberFilter(field_name='hourly_rate', lookup_expr='gte')
       max_price = django_filters.NumberFilter(field_name='hourly_rate', lookup_expr='lte')
       subject = django_filters.CharFilter(method='filter_by_subject')

       def filter_by_subject(self, queryset, name, value):
           return queryset.filter(subjects__contains=[value])

       class Meta:
           model = Tutor
           fields = ['is_verified', 'min_price', 'max_price', 'subject']
   ```

5. **TanStack Table для админки:**
   ```tsx
   // components/admin/tutors-table.tsx
   import { useReactTable, getCoreRowModel } from '@tanstack/react-table';

   const columns = [
     { accessorKey: 'fullName', header: 'Имя' },
     { accessorKey: 'hourlyRate', header: 'Цена/час' },
     { accessorKey: 'isVerified', header: 'Верифицирован', cell: BooleanCell },
     { id: 'actions', cell: ActionsCell },
   ];
   ```

6. **Infinite scroll** для мобильных:
   ```tsx
   import { useInfiniteQuery } from '@tanstack/react-query';
   import { useInView } from 'react-intersection-observer';

   function TutorInfiniteList() {
     const { ref, inView } = useInView();
     const { data, fetchNextPage, hasNextPage } = useInfiniteQuery({
       queryKey: ['tutors', filters],
       queryFn: ({ pageParam }) => getTutors({ ...filters, page: pageParam }),
       getNextPageParam: (lastPage) => lastPage.nextPage,
     });

     useEffect(() => {
       if (inView && hasNextPage) fetchNextPage();
     }, [inView, hasNextPage]);

     return (
       <>
         {data?.pages.flatMap(page => page.results).map(tutor => (
           <TutorCard key={tutor.id} tutor={tutor} />
         ))}
         <div ref={ref} />
       </>
     );
   }
   ```

7. **SSG для профилей** (`/tutors/[slug]`):
   ```tsx
   // app/tutors/[slug]/page.tsx
   export async function generateStaticParams() {
     const tutors = await getAllTutorSlugs();
     return tutors.map((tutor) => ({ slug: tutor.slug }));
   }

   export async function generateMetadata({ params }: Props): Promise<Metadata> {
     const tutor = await getTutorBySlug(params.slug);
     return {
       title: `${tutor.fullName} — Репетитор`,
       description: tutor.bio.slice(0, 160),
       openGraph: { images: [tutor.avatarUrl] },
     };
   }
   ```

**Acceptance Criteria:**
- [ ] Фильтры синхронизируются с URL
- [ ] SSR работает для SEO
- [ ] Infinite scroll на мобильных
- [ ] Skeleton loading при загрузке
- [ ] Keyboard navigation в таблице

---

## Итерация 6 — WebSocket чат (Django Channels)

**Цель:** real-time коммуникация между репетитором и учеником.

**Что делаем:**

1. **Django Channels настройка:**
   ```python
   # config/asgi.py
   from channels.routing import ProtocolTypeRouter, URLRouter
   from channels.auth import AuthMiddlewareStack
   from apps.chat.routing import websocket_urlpatterns

   application = ProtocolTypeRouter({
       "http": get_asgi_application(),
       "websocket": AuthMiddlewareStack(
           URLRouter(websocket_urlpatterns)
       ),
   })
   ```

   ```python
   # config/settings.py
   CHANNEL_LAYERS = {
       "default": {
           "BACKEND": "channels_redis.core.RedisChannelLayer",
           "CONFIG": {"hosts": [env("REDIS_URL")]},
       },
   }
   ```

2. **WebSocket Consumer:**
   ```python
   # apps/chat/consumers.py
   from channels.generic.websocket import AsyncJsonWebsocketConsumer

   class ChatConsumer(AsyncJsonWebsocketConsumer):
       async def connect(self):
           self.room_id = self.scope['url_route']['kwargs']['room_id']
           self.room_group = f'chat_{self.room_id}'

           await self.channel_layer.group_add(self.room_group, self.channel_name)
           await self.accept()

       async def receive_json(self, content):
           message_type = content.get('type')

           if message_type == 'message':
               await self.save_message(content)
               await self.channel_layer.group_send(
                   self.room_group,
                   {'type': 'chat_message', **content}
               )
           elif message_type == 'typing':
               await self.channel_layer.group_send(
                   self.room_group,
                   {'type': 'typing_indicator', 'user_id': self.scope['user'].id}
               )

       async def chat_message(self, event):
           await self.send_json(event)
   ```

3. **Frontend WebSocket hook:**
   ```tsx
   // hooks/use-chat.ts
   import { useEffect, useCallback } from 'react';
   import { useChatStore } from '@/stores/chat-store';

   export function useChat(roomId: string) {
     const { messages, addMessage, setTyping } = useChatStore();
     const wsRef = useRef<WebSocket | null>(null);

     useEffect(() => {
       const ws = new WebSocket(`ws://localhost:8000/ws/chat/${roomId}/`);
       wsRef.current = ws;

       ws.onmessage = (event) => {
         const data = JSON.parse(event.data);
         if (data.type === 'chat_message') {
           addMessage(data);
         } else if (data.type === 'typing_indicator') {
           setTyping(data.user_id, true);
         }
       };

       return () => ws.close();
     }, [roomId]);

     const sendMessage = useCallback((content: string) => {
       wsRef.current?.send(JSON.stringify({ type: 'message', content }));
     }, []);

     return { messages, sendMessage };
   }
   ```

4. **Zustand store для чата:**
   ```typescript
   // stores/chat-store.ts
   import { create } from 'zustand';

   interface ChatStore {
     messages: Message[];
     typingUsers: Set<number>;
     addMessage: (msg: Message) => void;
     setTyping: (userId: number, isTyping: boolean) => void;
   }

   export const useChatStore = create<ChatStore>((set) => ({
     messages: [],
     typingUsers: new Set(),
     addMessage: (msg) => set((s) => ({ messages: [...s.messages, msg] })),
     setTyping: (userId, isTyping) => set((s) => {
       const next = new Set(s.typingUsers);
       isTyping ? next.add(userId) : next.delete(userId);
       return { typingUsers: next };
     }),
   }));
   ```

5. **Optimistic updates и анимации:**
   ```tsx
   function ChatMessage({ message }: { message: Message }) {
     return (
       <motion.div
         initial={{ opacity: 0, y: 10, scale: 0.95 }}
         animate={{ opacity: 1, y: 0, scale: 1 }}
         className={cn(
           'max-w-[70%] rounded-2xl px-4 py-2',
           message.isMine ? 'ml-auto bg-primary text-white' : 'bg-muted'
         )}
       >
         {message.content}
         {message.isPending && <Spinner className="ml-2 h-3 w-3" />}
       </motion.div>
     );
   }
   ```

6. **Docker: Uvicorn для ASGI:**
   ```dockerfile
   # docker/backend/Dockerfile
   CMD ["uvicorn", "config.asgi:application", "--host", "0.0.0.0", "--port", "8000", "--reload"]
   ```

**Acceptance Criteria:**
- [ ] Сообщения доставляются в реальном времени
- [ ] Typing indicator работает
- [ ] История сообщений загружается при открытии
- [ ] Optimistic updates для отправки
- [ ] Анимации плавные

---

## Итерация 7 — Mock Stripe платежи

**Цель:** полностью mock-ированная платёжная система.

**Что делаем:**

1. **Payment Gateway App** (Django):
   ```python
   # apps/payments/models.py
   class Payment(models.Model):
       STATUS_CHOICES = [
           ('pending', 'Pending'),
           ('processing', 'Processing'),
           ('succeeded', 'Succeeded'),
           ('failed', 'Failed'),
           ('refunded', 'Refunded'),
       ]

       id = models.UUIDField(primary_key=True, default=uuid.uuid4)
       payment_intent_id = models.CharField(max_length=50, unique=True)  # pi_...
       amount = models.DecimalField(max_digits=10, decimal_places=2)
       currency = models.CharField(max_length=3, default='RUB')
       status = models.CharField(max_length=20, choices=STATUS_CHOICES)
       booking = models.ForeignKey('bookings.Booking', on_delete=models.CASCADE)
       user = models.ForeignKey(User, on_delete=models.CASCADE)
       metadata = models.JSONField(default=dict)
       created_at = models.DateTimeField(auto_now_add=True)
       updated_at = models.DateTimeField(auto_now=True)
   ```

2. **Mock Payment Intent API:**
   ```python
   # apps/payments/views.py
   class CreatePaymentIntentView(APIView):
       def post(self, request):
           serializer = CreatePaymentIntentSerializer(data=request.data)
           serializer.is_valid(raise_exception=True)

           payment = Payment.objects.create(
               payment_intent_id=f"pi_{uuid.uuid4().hex[:24]}",
               amount=serializer.validated_data['amount'],
               status='pending',
               booking_id=serializer.validated_data['booking_id'],
               user=request.user,
           )

           return Response({
               'payment_intent_id': payment.payment_intent_id,
               'client_secret': f"{payment.payment_intent_id}_secret_{uuid.uuid4().hex[:24]}",
               'amount': payment.amount,
               'status': payment.status,
           })

   class ConfirmPaymentView(APIView):
       def post(self, request):
           payment = get_object_or_404(
               Payment,
               payment_intent_id=request.data['payment_intent_id']
           )

           # Симуляция: 90% успех, 10% fail
           if random.random() < 0.9:
               payment.status = 'succeeded'
               payment.save()
               # Trigger webhook-like callback
               process_successful_payment.delay(payment.id)
           else:
               payment.status = 'failed'
               payment.save()

           return Response({'status': payment.status})
   ```

3. **Webhook симуляция:**
   ```python
   # apps/payments/views.py
   class WebhookSimulatorView(APIView):
       """Admin-only endpoint для тестирования webhook flows"""
       permission_classes = [IsAdminUser]

       def post(self, request):
           event_type = request.data['event_type']  # payment_intent.succeeded
           payment_intent_id = request.data['payment_intent_id']

           payment = Payment.objects.get(payment_intent_id=payment_intent_id)

           if event_type == 'payment_intent.succeeded':
               payment.status = 'succeeded'
           elif event_type == 'payment_intent.failed':
               payment.status = 'failed'

           payment.save()
           return Response({'processed': True})
   ```

4. **Frontend mock checkout:**
   ```tsx
   // components/checkout/payment-form.tsx
   import { useCreatePaymentIntent, useConfirmPayment } from '@/generated/api/payments';

   export function PaymentForm({ bookingId }: { bookingId: string }) {
     const createIntent = useCreatePaymentIntent();
     const confirmPayment = useConfirmPayment();
     const [step, setStep] = useState<'card' | 'processing' | 'result'>('card');

     const handleSubmit = async (cardData: CardData) => {
       setStep('processing');

       const { payment_intent_id, client_secret } = await createIntent.mutateAsync({
         booking_id: bookingId,
         amount: 1500,
       });

       // Симуляция задержки обработки карты
       await new Promise(r => setTimeout(r, 2000));

       const result = await confirmPayment.mutateAsync({
         payment_intent_id,
         card_number: cardData.number, // Тестовые карты: 4242... = success
       });

       setStep('result');
     };

     return (
       <AnimatePresence mode="wait">
         {step === 'card' && <CardInputForm onSubmit={handleSubmit} />}
         {step === 'processing' && <ProcessingAnimation />}
         {step === 'result' && <PaymentResult status={confirmPayment.data?.status} />}
       </AnimatePresence>
     );
   }
   ```

5. **Тестовые карты:**
   ```
   4242 4242 4242 4242 — Success
   4000 0000 0000 0002 — Declined
   4000 0000 0000 9995 — Insufficient funds
   ```

**Acceptance Criteria:**
- [ ] Payment flow работает end-to-end
- [ ] Тестовые карты работают как ожидается
- [ ] Webhook симулятор в админке
- [ ] Idempotency (повторный запрос не создаёт дубль)
- [ ] Документация по замене на реальный Stripe

---

## Итерация 8 — OpenSearch: полнотекстовый поиск

**Цель:** быстрый и релевантный поиск по профилям.

**Что делаем:**

1. **Docker Compose:**
   ```yaml
   opensearch:
     image: opensearchproject/opensearch:2.17.0
     environment:
       - discovery.type=single-node
       - DISABLE_SECURITY_PLUGIN=true
       - OPENSEARCH_JAVA_OPTS=-Xms512m -Xmx512m
     ports: ["9200:9200"]
     volumes: ["opensearch_data:/usr/share/opensearch/data"]
   ```

2. **Индекс репетиторов:**
   ```python
   # apps/search/indices.py
   TUTOR_INDEX_MAPPING = {
       "mappings": {
           "properties": {
               "id": {"type": "integer"},
               "full_name": {"type": "text", "analyzer": "russian"},
               "headline": {"type": "text", "analyzer": "russian", "boost": 2.0},
               "bio": {"type": "text", "analyzer": "russian"},
               "subjects": {"type": "keyword"},
               "hourly_rate": {"type": "float"},
               "rating": {"type": "float"},
               "location": {"type": "geo_point"},
               "embedding": {"type": "knn_vector", "dimension": 1536},  # для итерации 9
           }
       }
   }
   ```

3. **Индексация через Celery:**
   ```python
   # apps/search/tasks.py
   from celery import shared_task
   from opensearchpy import OpenSearch

   @shared_task
   def index_tutor(tutor_id: int):
       tutor = Tutor.objects.select_related('user').get(id=tutor_id)
       client = OpenSearch(hosts=[settings.OPENSEARCH_HOST])

       doc = {
           'id': tutor.id,
           'full_name': f"{tutor.user.first_name} {tutor.user.last_name}",
           'headline': tutor.headline,
           'bio': tutor.bio,
           'subjects': tutor.subjects,
           'hourly_rate': float(tutor.hourly_rate),
           'rating': tutor.rating,
       }

       client.index(index='tutors', id=tutor.id, body=doc)

   # Signal для автоиндексации
   @receiver(post_save, sender=Tutor)
   def on_tutor_save(sender, instance, **kwargs):
       index_tutor.delay(instance.id)
   ```

4. **Search API:**
   ```python
   # apps/search/views.py
   class SearchView(APIView):
       def get(self, request):
           query = request.query_params.get('q', '')
           filters = {
               'subjects': request.query_params.getlist('subject'),
               'min_price': request.query_params.get('min_price'),
               'max_price': request.query_params.get('max_price'),
           }

           search_body = {
               "query": {
                   "bool": {
                       "must": [
                           {
                               "multi_match": {
                                   "query": query,
                                   "fields": ["full_name^3", "headline^2", "bio"],
                                   "fuzziness": "AUTO",
                               }
                           }
                       ],
                       "filter": self._build_filters(filters),
                   }
               },
               "highlight": {
                   "fields": {"headline": {}, "bio": {}},
                   "pre_tags": ["<mark>"],
                   "post_tags": ["</mark>"],
               },
           }

           result = client.search(index='tutors', body=search_body)
           return Response(self._format_results(result))
   ```

5. **Frontend с подсветкой:**
   ```tsx
   function SearchResult({ hit }: { hit: SearchHit }) {
     return (
       <Card>
         <h3>{hit.full_name}</h3>
         <p
           className="text-muted-foreground"
           dangerouslySetInnerHTML={{ __html: hit.highlight?.headline?.[0] || hit.headline }}
         />
       </Card>
     );
   }
   ```

**Acceptance Criteria:**
- [ ] Поиск работает с подсветкой
- [ ] Fuzzy matching находит с опечатками
- [ ] Автоиндексация при изменении профиля
- [ ] Фильтры комбинируются с поиском

---

## Итерация 9 — Семантический поиск (OpenAI Embeddings + pgvector)

**Цель:** поиск по смыслу, а не только по ключевым словам.

**Что делаем:**

1. **pgvector в PostgreSQL:**
   ```sql
   CREATE EXTENSION IF NOT EXISTS vector;

   ALTER TABLE tutors_tutor ADD COLUMN embedding vector(1536);
   CREATE INDEX ON tutors_tutor USING ivfflat (embedding vector_cosine_ops);
   ```

2. **Генерация embeddings:**
   ```python
   # apps/search/embeddings.py
   import openai

   def get_embedding(text: str) -> list[float]:
       if settings.MOCK_OPENAI:
           # Возвращаем детерминированный mock embedding
           return [hash(text) % 100 / 100] * 1536

       response = openai.embeddings.create(
           model="text-embedding-3-small",
           input=text,
       )
       return response.data[0].embedding

   @shared_task
   def generate_tutor_embedding(tutor_id: int):
       tutor = Tutor.objects.get(id=tutor_id)
       text = f"{tutor.headline} {tutor.bio} {' '.join(tutor.subjects)}"

       embedding = get_embedding(text)
       tutor.embedding = embedding
       tutor.save(update_fields=['embedding'])
   ```

3. **Hybrid search API:**
   ```python
   # apps/search/views.py
   class SemanticSearchView(APIView):
       def get(self, request):
           query = request.query_params.get('q')

           # 1. Получаем embedding запроса
           query_embedding = get_embedding(query)

           # 2. Vector search в pgvector
           vector_results = Tutor.objects.annotate(
               similarity=CosineDistance('embedding', query_embedding)
           ).order_by('similarity')[:50]

           # 3. Full-text search в OpenSearch
           text_results = opensearch_search(query)

           # 4. Hybrid ranking (RRF - Reciprocal Rank Fusion)
           combined = reciprocal_rank_fusion(
               vector_results,
               text_results,
               k=60
           )

           return Response(combined[:20])
   ```

4. **Frontend UI:**
   ```tsx
   function SearchBar() {
     const [mode, setMode] = useState<'text' | 'semantic'>('text');

     return (
       <div className="flex gap-2">
         <Input placeholder="Найти репетитора..." />
         <ToggleGroup value={mode} onValueChange={setMode}>
           <ToggleGroupItem value="text">По словам</ToggleGroupItem>
           <ToggleGroupItem value="semantic">По смыслу</ToggleGroupItem>
         </ToggleGroup>
       </div>
     );
   }
   ```

**Acceptance Criteria:**
- [ ] Семантический поиск находит релевантные результаты
- [ ] "нужен математик для ЕГЭ" находит репетиторов математики
- [ ] Hybrid ranking улучшает качество
- [ ] Mock режим работает без OpenAI ключа

---

## Итерация 10 — Feature Flags (Unleash) + A/B тесты

**Цель:** контролируемый rollout фич и эксперименты.

**Что делаем:**

1. **Docker Compose:**
   ```yaml
   unleash:
     image: unleashorg/unleash-server:latest
     environment:
       DATABASE_URL: postgresql://tutors:secret@db:5432/unleash
       DATABASE_SSL: "false"
     ports: ["4242:4242"]
     depends_on: [db]
   ```

2. **Backend интеграция:**
   ```python
   # apps/core/feature_flags.py
   from UnleashClient import UnleashClient

   unleash = UnleashClient(
       url=settings.UNLEASH_URL,
       app_name="tutors-backend",
       instance_id="backend-1",
   )
   unleash.initialize_client()

   def is_enabled(flag: str, user_id: int | None = None) -> bool:
       context = {"userId": str(user_id)} if user_id else {}
       return unleash.is_enabled(flag, context)
   ```

3. **Frontend интеграция:**
   ```tsx
   // providers/unleash-provider.tsx
   import { FlagProvider } from '@unleash/proxy-client-react';

   const config = {
     url: process.env.NEXT_PUBLIC_UNLEASH_URL,
     clientKey: process.env.NEXT_PUBLIC_UNLEASH_CLIENT_KEY,
     appName: 'tutors-frontend',
   };

   export function UnleashProvider({ children }: { children: React.ReactNode }) {
     return <FlagProvider config={config}>{children}</FlagProvider>;
   }
   ```

   ```tsx
   // Использование
   import { useFlag } from '@unleash/proxy-client-react';

   function TutorCard({ tutor }: { tutor: Tutor }) {
     const useNewCard = useFlag('tutor_card_v2');

     return useNewCard ? (
       <TutorCardV2 tutor={tutor} />
     ) : (
       <TutorCardV1 tutor={tutor} />
     );
   }
   ```

4. **Определяемые флаги:**
   - `tutor_card_v2` — новый дизайн карточки (A/B test)
   - `semantic_search` — включить семантический поиск
   - `new_checkout_flow` — новый flow оплаты
   - `chat_reactions` — реакции в чате

5. **Трекинг экспериментов:**
   ```typescript
   // lib/analytics.ts
   export function trackExposure(flagName: string, variant: string, userId: string) {
     fetch('/api/analytics/exposure', {
       method: 'POST',
       body: JSON.stringify({ flag: flagName, variant, userId, timestamp: Date.now() }),
     });
   }
   ```

**Acceptance Criteria:**
- [ ] Unleash UI доступен на localhost:4242
- [ ] Флаги работают на FE и BE
- [ ] A/B тест показывает разные варианты разным пользователям
- [ ] Exposure events логируются

---

# Итог: что демонстрируется по завершении

## Frontend
- Next.js 15 App Router + React Server Components
- Tailwind v4 CSS-first конфигурация
- shadcn/ui + Radix primitives
- TanStack Query v5 + TanStack Table v8
- React Hook Form + Zod v4 (сложные формы)
- Zustand (клиентское состояние)
- Motion (анимации)
- Type-safe URL params (nuqs)
- Vitest + RTL + MSW (тестирование)

## Backend
- Django 5.2 LTS + DRF
- Django Channels (WebSockets)
- OpenAPI 3.1 (drf-spectacular)
- PostgreSQL + pgvector
- OpenSearch (полнотекстовый поиск)
- Celery (фоновые задачи)
- pytest + factory_boy (тестирование)

## Инфраструктура
- Docker Compose (полное окружение)
- MinIO (S3-compatible storage)
- Redis (кеш, Channels, Celery)
- Unleash (feature flags)
- GitHub Actions CI

## Практики
- OpenAPI → TypeScript автогенерация (orval)
- Документированный UI-kit
- Comprehensive тестирование
- Mock-подходы для внешних сервисов
