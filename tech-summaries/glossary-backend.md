# Глоссарий бэкенд-терминов

> Простые объяснения терминов из backend.md для быстрого повторения перед собеседованием.

## Содержание

1. [Event-Driven Architecture](#1-event-driven-architecture)
2. [CQRS](#2-cqrs)
3. [Payment Processing](#3-payment-processing)
4. [Real-Time Communication](#4-real-time-communication)
5. [Feature Flags & A/B Testing](#5-feature-flags--ab-testing)
6. [Async Tasks](#6-async-tasks)
7. [Общие паттерны](#7-общие-паттерны)

---

## 1. Event-Driven Architecture

### Dual-Write Problem (Проблема двойной записи)

**Что это:** Ситуация, когда нужно записать данные в два места (например, БД и Kafka), но одна из записей может упасть.

**Простым языком:** Ты сохранил репетитора в PostgreSQL, но Kafka лежал. Теперь в БД данные есть, а событие для поиска не ушло. Search index рассинхронизирован.

**Решение:** Transactional Outbox Pattern.

---

### Transactional Outbox Pattern

**Что это:** Паттерн, при котором событие записывается в ту же БД, что и основные данные, в одной транзакции.

**Простым языком:** Вместо "сохранить в БД → отправить в Kafka" делаем "сохранить в БД + записать событие в таблицу outbox → отдельный процесс читает outbox и отправляет в Kafka".

**Зачем:** Гарантирует, что если данные сохранились — событие тоже сохранилось. Атомарность.

**Гарантии:**
- **Atomicity** — данные и событие в одной транзакции
- **Ordering** — события отсортированы по времени создания
- **At-least-once delivery** — событие помечается опубликованным только после ACK от Kafka

---

### transaction.on_commit()

**Что это:** Django механизм для выполнения кода только после успешного коммита транзакции.

**Простым языком:** `post_save` сигнал срабатывает ДО коммита. Если транзакция откатится — сигнал уже сработал зря. `on_commit` гарантирует выполнение только после успешного коммита.

**Когда использовать:** Когда побочный эффект (отправка email, создание события) должен произойти только если транзакция прошла.

---

### Double-Checked Locking

**Что это:** Паттерн для thread-safe создания singleton с минимальной блокировкой.

**Простым языком:**
1. Первая проверка без lock — быстрый путь для 99% вызовов (объект уже создан)
2. Lock только когда объект не создан
3. Вторая проверка под lock — защита от race condition (другой поток мог создать объект пока мы ждали lock)

**Зачем:** Избегаем дорогой блокировки на каждый вызов, но сохраняем thread-safety.

---

### Kafka

**Что это:** Распределённая платформа для обмена сообщениями (message broker).

**Простым языком:** Очередь сообщений, которая:
- Хранит сообщения на диске (не теряются)
- Масштабируется горизонтально
- Гарантирует порядок внутри partition

**Основные понятия:**
- **Topic** — категория сообщений (например, `tutor-events`)
- **Partition** — раздел топика для параллелизма
- **Consumer Group** — группа потребителей, которые делят нагрузку
- **Offset** — позиция в логе сообщений

---

### At-Least-Once vs At-Most-Once vs Exactly-Once

**At-Least-Once (хотя бы раз):**
- Сообщение может быть доставлено несколько раз
- Получатель должен быть idempotent
- Используется в проекте

**At-Most-Once (не более раза):**
- Сообщение может быть потеряно
- Никогда не дублируется
- Подходит для метрик

**Exactly-Once (ровно раз):**
- Сложно реализовать
- Требует транзакций на обоих концах
- Обычно эмулируется через at-least-once + idempotency

---

## 2. CQRS

### CQRS (Command Query Responsibility Segregation)

**Что это:** Архитектурный паттерн разделения операций чтения и записи.

**Простым языком:** Write Side (Django + PostgreSQL) отвечает за изменения. Read Side (OpenSearch) оптимизирован для поиска. Они связаны через события.

**Зачем:**
- Независимое масштабирование (поиск нагружен больше — добавляем реплики OpenSearch)
- Оптимизация под задачу (PostgreSQL для ACID, OpenSearch для полнотекстового поиска)
- Изоляция сбоев (Kafka — буфер между системами)

---

### Eventual Consistency (Согласованность в конечном счёте)

**Что это:** Модель консистентности, при которой данные синхронизируются не мгновенно, а через некоторое время.

**Простым языком:** После сохранения репетитора в PostgreSQL, он появится в поиске через 1-2 секунды, не мгновенно.

**Trade-off:** Теряем strong consistency, получаем масштабируемость и отказоустойчивость.

---

### Read Model Projection

**Что это:** Процесс построения read-оптимизированной модели данных из событий.

**Простым языком:** Go-сервис слушает события из Kafka и обновляет OpenSearch. Это и есть "проекция" — преобразование событий в read model.

**Ключевое свойство:** Idempotent — можно replay события без дублирования.

---

### Idempotent Operation

**Что это:** Операция, которую можно выполнить несколько раз с тем же результатом.

**Простым языком:** `UpsertTutor(id=1, name="John")` — сколько раз не вызови, результат один: репетитор с id=1 имеет имя John.

**Зачем:** При at-least-once delivery сообщение может прийти дважды. Idempotent операция это переживёт.

**Примеры:**
- `INSERT ... ON CONFLICT UPDATE` — idempotent
- `INSERT` без проверки — NOT idempotent (будут дубли)
- `counter++` — NOT idempotent
- `counter = 5` — idempotent

---

## 3. Payment Processing

### Idempotency Key

**Что это:** Уникальный ключ, который клиент передаёт с запросом для предотвращения дублирования.

**Простым языком:** Клиент отправил запрос на оплату, получил timeout, повторил. Сервер видит тот же idempotency_key и возвращает существующий платёж вместо создания нового.

**Как работает:**
1. Клиент генерирует UUID
2. Сервер проверяет: есть ли платёж с таким ключом?
3. Есть → возвращает существующий
4. Нет → создаёт новый

---

### Payment State Machine

**Что это:** Конечный автомат состояний платежа с чёткими переходами.

**Состояния:**
```
PENDING → PROCESSING → SUCCEEDED
                    → FAILED
SUCCEEDED → REFUNDED
```

**Ключевой принцип:** Финальный статус (succeeded/failed) устанавливается только через webhook от платёжной системы, не через confirm endpoint. Это предотвращает race conditions.

---

### Webhook

**Что это:** HTTP endpoint, который вызывает внешний сервис для уведомления о событиях.

**Простым языком:** Stripe обработал платёж и вызывает твой `/webhooks/stripe/` endpoint с результатом. Ты не polling'аешь Stripe — он сам тебе сообщает.

**Особенности:**
- Нужно проверять подпись (signature verification)
- Обработка должна быть idempotent
- Нужно быстро ответить 200 (тяжёлую работу — в фоновую задачу)

---

### Stripe Test Cards

**Что это:** Специальные номера карт для тестирования разных сценариев.

**Примеры:**
- `4242424242424242` — успешная оплата
- `4000000000000002` — отклонена
- `4000000000009995` — недостаточно средств

---

## 4. Real-Time Communication

### WebSocket

**Что это:** Протокол для двунаправленной связи между клиентом и сервером.

**Отличие от HTTP:**
- HTTP: клиент спрашивает → сервер отвечает
- WebSocket: постоянное соединение, обе стороны могут отправлять сообщения в любой момент

**Когда использовать:** Чаты, уведомления, live updates, игры.

---

### Django Channels

**Что это:** Расширение Django для работы с WebSocket и async протоколами.

**Основные понятия:**
- **Consumer** — класс, обрабатывающий WebSocket соединения (аналог View)
- **Channel Layer** — абстракция для обмена сообщениями между consumers (обычно Redis)
- **ASGI** — асинхронный интерфейс (вместо WSGI для обычных запросов)

---

### Channel Layer

**Что это:** Механизм для обмена сообщениями между разными consumers.

**Простым языком:** У тебя 5 инстансов Daphne, каждый обслуживает часть пользователей. Когда юзер А отправляет сообщение в чат, нужно доставить его юзеру Б, который подключён к другому инстансу. Channel Layer (Redis) решает эту задачу.

**Операции:**
- `group_add(group_name, channel_name)` — добавить в группу
- `group_send(group_name, message)` — отправить всем в группе
- `group_discard(group_name, channel_name)` — удалить из группы

---

### ASGI (Asynchronous Server Gateway Interface)

**Что это:** Асинхронная версия WSGI для Python веб-приложений.

**Простым языком:** WSGI — синхронный, один запрос = один поток. ASGI — асинхронный, поддерживает WebSocket, HTTP/2, long-polling.

**Серверы:** Daphne, Uvicorn, Hypercorn.

---

### database_sync_to_async

**Что это:** Django decorator для вызова синхронных ORM операций из async кода.

**Зачем:** Django ORM синхронный. В async consumer нельзя напрямую вызвать `User.objects.get()`. Декоратор оборачивает вызов в thread pool.

```python
@database_sync_to_async
def get_user(user_id):
    return User.objects.get(id=user_id)

# В async consumer:
user = await get_user(1)
```

---

### N+1 Query Problem

**Что это:** Проблема, когда для N записей выполняется N+1 запрос к БД.

**Пример:**
```python
# 1 запрос на все сообщения
messages = Message.objects.all()

for msg in messages:
    # +N запросов на авторов
    print(msg.author.name)
```

**Решение:**
```python
# select_related для ForeignKey
messages = Message.objects.select_related('author').all()

# prefetch_related для Many-to-Many
messages = Message.objects.prefetch_related('tags').all()

# Batch update вместо N updates
Message.objects.filter(id__in=ids).update(is_read=True)
```

---

## 5. Feature Flags & A/B Testing

### Feature Flag

**Что это:** Механизм для включения/выключения функциональности без деплоя.

**Простым языком:** Хочешь выкатить новый UI, но не уверен. Включаешь feature flag → 10% пользователей видят новый UI. Всё ок → постепенно увеличиваешь до 100%. Проблемы → выключаешь мгновенно.

**Типы:**
- **Release flag** — включить/выключить фичу
- **Experiment flag** — A/B тест с вариантами
- **Ops flag** — kill switch для нагрузки
- **Permission flag** — для конкретных пользователей

---

### Unleash

**Что это:** Open-source система управления feature flags.

**Возможности:**
- Gradual rollout (постепенное включение)
- User targeting (для конкретных пользователей)
- A/B testing с вариантами
- SDK для разных языков

---

### Variant

**Что это:** Один из вариантов в A/B эксперименте.

**Пример:**
```
Эксперимент: tutor_card_experiment
├── control (текущий дизайн) — 50%
├── variant_a (новые цвета) — 25%
└── variant_b (новый layout) — 25%
```

---

### Fail Closed

**Что это:** Стратегия обработки ошибок, при которой отказ системы приводит к "закрытому" (безопасному) состоянию.

**Простым языком:** Если Unleash недоступен — feature flag возвращает `false`. Лучше не показать новую фичу, чем сломать что-то.

**Противоположность:** Fail Open — при ошибке разрешаем действие.

---

## 6. Async Tasks

### Celery

**Что это:** Распределённая очередь задач для Python.

**Компоненты:**
- **Worker** — процесс, выполняющий задачи
- **Broker** — хранилище очереди (Redis, RabbitMQ)
- **Result Backend** — хранилище результатов (опционально)
- **Beat** — планировщик периодических задач

---

### Celery Beat

**Что это:** Планировщик для периодических задач в Celery.

**Простым языком:** Cron для Celery. Запускает задачи по расписанию.

```python
app.conf.beat_schedule = {
    'publish-outbox-events': {
        'task': 'apps.events.tasks.publish_outbox_events',
        'schedule': 1.0,  # Каждую секунду
    },
}
```

---

### @shared_task

**Что это:** Декоратор Celery для определения задачи без привязки к конкретному app.

**Параметры:**
- `bind=True` — передаёт `self` (доступ к retry, request)
- `max_retries=3` — максимум повторов
- `autoretry_for=(Exception,)` — автоматический retry для исключений

---

### Exponential Backoff

**Что это:** Стратегия повторных попыток с экспоненциально растущей задержкой.

**Простым языком:** 1-я попытка провалилась → жди 1 сек. 2-я провалилась → жди 2 сек. 3-я → 4 сек. И так далее.

**Формула:** `delay = base * 2^attempt`

**Зачем:** Даёт перегруженной системе время восстановиться. Предотвращает "thundering herd" — когда все клиенты одновременно ретраят.

---

### Task Chaining

**Что это:** Паттерн последовательного выполнения задач, где следующая зависит от предыдущей.

**Пример из проекта:**
```
confirm()
  → simulate_payment_provider.delay()
      → process_webhook_event.delay()
          → process_successful_payment.delay()
```

**Альтернативы в Celery:**
- `chain(task1.s(), task2.s())` — цепочка
- `group(task1.s(), task2.s())` — параллельно
- `chord(group, callback)` — параллельно, потом callback

---

## 7. Общие паттерны

### Singleton

**Что это:** Паттерн, гарантирующий единственный экземпляр класса.

**Когда использовать:**
- Database connection pool
- Kafka producer
- Logger
- Config

**Осторожно:** Усложняет тестирование, создаёт глобальное состояние.

---

### Lazy Initialization

**Что это:** Отложенное создание объекта до первого использования.

**Зачем:** Не создавать дорогие объекты (соединения) при импорте модуля. Создаём только когда реально нужно.

```python
# Плохо: соединение при импорте
producer = KafkaProducer()

# Хорошо: соединение при первом вызове
def get_producer():
    if _producer is None:
        _producer = KafkaProducer()
    return _producer
```

---

### Graceful Shutdown

**Что это:** Корректное завершение работы сервиса с обработкой текущих запросов.

**Шаги:**
1. Перестать принимать новые запросы
2. Дождаться завершения текущих
3. Закрыть соединения
4. Завершить процесс

**В Go (из проекта):**
```go
select {
case <-ctx.Done():
    logger.Info("Shutting down gracefully")
    return consumer.Close()  // Закрываем соединение
}
```

---

### Error Resilience

**Что это:** Способность системы продолжать работу при ошибках.

**Стратегии:**
- **Log and continue** — логируем ошибку, продолжаем обработку
- **Circuit Breaker** — после N ошибок временно прекращаем попытки
- **Retry with backoff** — повторяем с задержкой
- **Fallback** — возвращаем дефолтное значение

**Пример из проекта:**
```python
for event in events:
    try:
        process(event)
    except Exception as e:
        logger.error("Failed: %s", e)
        continue  # Не блокируем остальные события
```

---

### Race Condition

**Что это:** Ситуация, когда результат зависит от порядка выполнения параллельных операций.

**Пример:**
```python
# Два потока читают counter = 5
# Оба увеличивают: 5 + 1 = 6
# Оба записывают 6
# Ожидали 7, получили 6
```

**Решения:**
- Lock/Mutex
- Atomic operations
- Compare-and-swap
- Database transactions

---

### Aggregate (DDD)

**Что это:** Кластер связанных объектов, которые рассматриваются как единое целое.

**В контексте событий:** `aggregate_type` и `aggregate_id` в OutboxEvent указывают, к какому объекту относится событие.

**Пример:**
- Aggregate Type: `Tutor`
- Aggregate ID: `123`
- Event Type: `TutorUpdated`

---

### Consumer Group (Kafka)

**Что это:** Группа потребителей, которые совместно читают топик.

**Как работает:**
- Партиции распределяются между consumers в группе
- Один consumer может читать несколько партиций
- Одну партицию читает только один consumer из группы

**Зачем:** Горизонтальное масштабирование. Добавил consumer → нагрузка распределилась.

---

## Быстрая шпаргалка

| Термин | Одним предложением |
|--------|-------------------|
| Dual-Write | Запись в два места без гарантии согласованности |
| Transactional Outbox | Событие в той же транзакции, что и данные |
| CQRS | Разделение операций чтения и записи |
| Eventual Consistency | Данные синхронизируются не мгновенно |
| Idempotency | Повторный вызов даёт тот же результат |
| WebSocket | Двунаправленное соединение для real-time |
| Channel Layer | Обмен сообщениями между Django consumers |
| Feature Flag | Включение фичи без деплоя |
| Celery Beat | Планировщик периодических задач |
| Exponential Backoff | Retry с экспоненциально растущей задержкой |
| Graceful Shutdown | Корректное завершение с обработкой текущих запросов |

---

*Глоссарий создан на основе backend.md для быстрого повторения терминов.*
