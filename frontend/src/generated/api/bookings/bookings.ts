/**
 * Generated by orval v7.13.2 üç∫
 * Do not edit manually.
 * Tutors Marketplace API
 * API for Tutors Marketplace pet project
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  Booking,
  BookingRequest,
  BookingsListParams,
  CreateBooking,
  CreateBookingRequest,
  PaginatedBookingList,
  PatchedBookingRequest
} from '../../schemas';

import { customFetch } from '../../../lib/api-client';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Returns bookings for the authenticated user. Tutors see bookings where they are the tutor, students see their own bookings.
 * @summary List user's bookings
 */
export type bookingsListResponse200 = {
  data: PaginatedBookingList
  status: 200
}
    
export type bookingsListResponseSuccess = (bookingsListResponse200) & {
  headers: Headers;
};
;

export type bookingsListResponse = (bookingsListResponseSuccess)

export const getBookingsListUrl = (params?: BookingsListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/bookings/?${stringifiedParams}` : `/api/bookings/`
}

export const bookingsList = async (params?: BookingsListParams, options?: RequestInit): Promise<bookingsListResponse> => {
  
  return customFetch<bookingsListResponse>(getBookingsListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getBookingsListQueryKey = (params?: BookingsListParams,) => {
    return [
    `/api/bookings/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getBookingsListQueryOptions = <TData = Awaited<ReturnType<typeof bookingsList>>, TError = unknown>(params?: BookingsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bookingsList>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getBookingsListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof bookingsList>>> = () => bookingsList(params, requestOptions);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof bookingsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type BookingsListQueryResult = NonNullable<Awaited<ReturnType<typeof bookingsList>>>
export type BookingsListQueryError = unknown


export function useBookingsList<TData = Awaited<ReturnType<typeof bookingsList>>, TError = unknown>(
 params: undefined |  BookingsListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof bookingsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof bookingsList>>,
          TError,
          Awaited<ReturnType<typeof bookingsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBookingsList<TData = Awaited<ReturnType<typeof bookingsList>>, TError = unknown>(
 params?: BookingsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bookingsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof bookingsList>>,
          TError,
          Awaited<ReturnType<typeof bookingsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBookingsList<TData = Awaited<ReturnType<typeof bookingsList>>, TError = unknown>(
 params?: BookingsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bookingsList>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List user's bookings
 */

export function useBookingsList<TData = Awaited<ReturnType<typeof bookingsList>>, TError = unknown>(
 params?: BookingsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bookingsList>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getBookingsListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Create a new booking with a tutor. Price is automatically calculated based on tutor's hourly rate.
 * @summary Create a booking
 */
export type bookingsCreateResponse201 = {
  data: CreateBooking
  status: 201
}
    
export type bookingsCreateResponseSuccess = (bookingsCreateResponse201) & {
  headers: Headers;
};
;

export type bookingsCreateResponse = (bookingsCreateResponseSuccess)

export const getBookingsCreateUrl = () => {


  

  return `/api/bookings/`
}

export const bookingsCreate = async (createBookingRequest: CreateBookingRequest, options?: RequestInit): Promise<bookingsCreateResponse> => {
  
  return customFetch<bookingsCreateResponse>(getBookingsCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createBookingRequest,)
  }
);}




export const getBookingsCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bookingsCreate>>, TError,{data: CreateBookingRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof bookingsCreate>>, TError,{data: CreateBookingRequest}, TContext> => {

const mutationKey = ['bookingsCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof bookingsCreate>>, {data: CreateBookingRequest}> = (props) => {
          const {data} = props ?? {};

          return  bookingsCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BookingsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof bookingsCreate>>>
    export type BookingsCreateMutationBody = CreateBookingRequest
    export type BookingsCreateMutationError = unknown

    /**
 * @summary Create a booking
 */
export const useBookingsCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bookingsCreate>>, TError,{data: CreateBookingRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof bookingsCreate>>,
        TError,
        {data: CreateBookingRequest},
        TContext
      > => {

      const mutationOptions = getBookingsCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Returns detailed information about a specific booking.
 * @summary Get booking details
 */
export type bookingsRetrieveResponse200 = {
  data: Booking
  status: 200
}
    
export type bookingsRetrieveResponseSuccess = (bookingsRetrieveResponse200) & {
  headers: Headers;
};
;

export type bookingsRetrieveResponse = (bookingsRetrieveResponseSuccess)

export const getBookingsRetrieveUrl = (id: string,) => {


  

  return `/api/bookings/${id}/`
}

export const bookingsRetrieve = async (id: string, options?: RequestInit): Promise<bookingsRetrieveResponse> => {
  
  return customFetch<bookingsRetrieveResponse>(getBookingsRetrieveUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getBookingsRetrieveQueryKey = (id?: string,) => {
    return [
    `/api/bookings/${id}/`
    ] as const;
    }

    
export const getBookingsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof bookingsRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bookingsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getBookingsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof bookingsRetrieve>>> = () => bookingsRetrieve(id, requestOptions);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof bookingsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type BookingsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof bookingsRetrieve>>>
export type BookingsRetrieveQueryError = unknown


export function useBookingsRetrieve<TData = Awaited<ReturnType<typeof bookingsRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof bookingsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof bookingsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof bookingsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBookingsRetrieve<TData = Awaited<ReturnType<typeof bookingsRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bookingsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof bookingsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof bookingsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBookingsRetrieve<TData = Awaited<ReturnType<typeof bookingsRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bookingsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get booking details
 */

export function useBookingsRetrieve<TData = Awaited<ReturnType<typeof bookingsRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof bookingsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getBookingsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * ViewSet for managing bookings.

Provides CRUD operations for bookings with user-specific filtering.
 */
export type bookingsUpdateResponse200 = {
  data: Booking
  status: 200
}
    
export type bookingsUpdateResponseSuccess = (bookingsUpdateResponse200) & {
  headers: Headers;
};
;

export type bookingsUpdateResponse = (bookingsUpdateResponseSuccess)

export const getBookingsUpdateUrl = (id: string,) => {


  

  return `/api/bookings/${id}/`
}

export const bookingsUpdate = async (id: string,
    bookingRequest: BookingRequest, options?: RequestInit): Promise<bookingsUpdateResponse> => {
  
  return customFetch<bookingsUpdateResponse>(getBookingsUpdateUrl(id),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      bookingRequest,)
  }
);}




export const getBookingsUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bookingsUpdate>>, TError,{id: string;data: BookingRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof bookingsUpdate>>, TError,{id: string;data: BookingRequest}, TContext> => {

const mutationKey = ['bookingsUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof bookingsUpdate>>, {id: string;data: BookingRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  bookingsUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BookingsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof bookingsUpdate>>>
    export type BookingsUpdateMutationBody = BookingRequest
    export type BookingsUpdateMutationError = unknown

    export const useBookingsUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bookingsUpdate>>, TError,{id: string;data: BookingRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof bookingsUpdate>>,
        TError,
        {id: string;data: BookingRequest},
        TContext
      > => {

      const mutationOptions = getBookingsUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * ViewSet for managing bookings.

Provides CRUD operations for bookings with user-specific filtering.
 */
export type bookingsPartialUpdateResponse200 = {
  data: Booking
  status: 200
}
    
export type bookingsPartialUpdateResponseSuccess = (bookingsPartialUpdateResponse200) & {
  headers: Headers;
};
;

export type bookingsPartialUpdateResponse = (bookingsPartialUpdateResponseSuccess)

export const getBookingsPartialUpdateUrl = (id: string,) => {


  

  return `/api/bookings/${id}/`
}

export const bookingsPartialUpdate = async (id: string,
    patchedBookingRequest: PatchedBookingRequest, options?: RequestInit): Promise<bookingsPartialUpdateResponse> => {
  
  return customFetch<bookingsPartialUpdateResponse>(getBookingsPartialUpdateUrl(id),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      patchedBookingRequest,)
  }
);}




export const getBookingsPartialUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bookingsPartialUpdate>>, TError,{id: string;data: PatchedBookingRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof bookingsPartialUpdate>>, TError,{id: string;data: PatchedBookingRequest}, TContext> => {

const mutationKey = ['bookingsPartialUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof bookingsPartialUpdate>>, {id: string;data: PatchedBookingRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  bookingsPartialUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BookingsPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof bookingsPartialUpdate>>>
    export type BookingsPartialUpdateMutationBody = PatchedBookingRequest
    export type BookingsPartialUpdateMutationError = unknown

    export const useBookingsPartialUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bookingsPartialUpdate>>, TError,{id: string;data: PatchedBookingRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof bookingsPartialUpdate>>,
        TError,
        {id: string;data: PatchedBookingRequest},
        TContext
      > => {

      const mutationOptions = getBookingsPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * ViewSet for managing bookings.

Provides CRUD operations for bookings with user-specific filtering.
 */
export type bookingsDestroyResponse204 = {
  data: void
  status: 204
}
    
export type bookingsDestroyResponseSuccess = (bookingsDestroyResponse204) & {
  headers: Headers;
};
;

export type bookingsDestroyResponse = (bookingsDestroyResponseSuccess)

export const getBookingsDestroyUrl = (id: string,) => {


  

  return `/api/bookings/${id}/`
}

export const bookingsDestroy = async (id: string, options?: RequestInit): Promise<bookingsDestroyResponse> => {
  
  return customFetch<bookingsDestroyResponse>(getBookingsDestroyUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getBookingsDestroyMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bookingsDestroy>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof bookingsDestroy>>, TError,{id: string}, TContext> => {

const mutationKey = ['bookingsDestroy'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof bookingsDestroy>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  bookingsDestroy(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BookingsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof bookingsDestroy>>>
    
    export type BookingsDestroyMutationError = unknown

    export const useBookingsDestroy = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bookingsDestroy>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof bookingsDestroy>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getBookingsDestroyMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Cancel a pending or confirmed booking. Both tutors and students can cancel their bookings.
 * @summary Cancel a booking
 */
export type bookingsCancelCreateResponse200 = {
  data: Booking
  status: 200
}
    
export type bookingsCancelCreateResponseSuccess = (bookingsCancelCreateResponse200) & {
  headers: Headers;
};
;

export type bookingsCancelCreateResponse = (bookingsCancelCreateResponseSuccess)

export const getBookingsCancelCreateUrl = (id: string,) => {


  

  return `/api/bookings/${id}/cancel/`
}

export const bookingsCancelCreate = async (id: string,
    bookingRequest: BookingRequest, options?: RequestInit): Promise<bookingsCancelCreateResponse> => {
  
  return customFetch<bookingsCancelCreateResponse>(getBookingsCancelCreateUrl(id),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      bookingRequest,)
  }
);}




export const getBookingsCancelCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bookingsCancelCreate>>, TError,{id: string;data: BookingRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof bookingsCancelCreate>>, TError,{id: string;data: BookingRequest}, TContext> => {

const mutationKey = ['bookingsCancelCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof bookingsCancelCreate>>, {id: string;data: BookingRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  bookingsCancelCreate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BookingsCancelCreateMutationResult = NonNullable<Awaited<ReturnType<typeof bookingsCancelCreate>>>
    export type BookingsCancelCreateMutationBody = BookingRequest
    export type BookingsCancelCreateMutationError = unknown

    /**
 * @summary Cancel a booking
 */
export const useBookingsCancelCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bookingsCancelCreate>>, TError,{id: string;data: BookingRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof bookingsCancelCreate>>,
        TError,
        {id: string;data: BookingRequest},
        TContext
      > => {

      const mutationOptions = getBookingsCancelCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Mark a confirmed booking as completed. Only the tutor can complete bookings.
 * @summary Complete a booking
 */
export type bookingsCompleteCreateResponse200 = {
  data: Booking
  status: 200
}
    
export type bookingsCompleteCreateResponseSuccess = (bookingsCompleteCreateResponse200) & {
  headers: Headers;
};
;

export type bookingsCompleteCreateResponse = (bookingsCompleteCreateResponseSuccess)

export const getBookingsCompleteCreateUrl = (id: string,) => {


  

  return `/api/bookings/${id}/complete/`
}

export const bookingsCompleteCreate = async (id: string,
    bookingRequest: BookingRequest, options?: RequestInit): Promise<bookingsCompleteCreateResponse> => {
  
  return customFetch<bookingsCompleteCreateResponse>(getBookingsCompleteCreateUrl(id),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      bookingRequest,)
  }
);}




export const getBookingsCompleteCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bookingsCompleteCreate>>, TError,{id: string;data: BookingRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof bookingsCompleteCreate>>, TError,{id: string;data: BookingRequest}, TContext> => {

const mutationKey = ['bookingsCompleteCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof bookingsCompleteCreate>>, {id: string;data: BookingRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  bookingsCompleteCreate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BookingsCompleteCreateMutationResult = NonNullable<Awaited<ReturnType<typeof bookingsCompleteCreate>>>
    export type BookingsCompleteCreateMutationBody = BookingRequest
    export type BookingsCompleteCreateMutationError = unknown

    /**
 * @summary Complete a booking
 */
export const useBookingsCompleteCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bookingsCompleteCreate>>, TError,{id: string;data: BookingRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof bookingsCompleteCreate>>,
        TError,
        {id: string;data: BookingRequest},
        TContext
      > => {

      const mutationOptions = getBookingsCompleteCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Confirm a pending booking. Only the tutor can confirm bookings.
 * @summary Confirm a booking
 */
export type bookingsConfirmCreateResponse200 = {
  data: Booking
  status: 200
}
    
export type bookingsConfirmCreateResponseSuccess = (bookingsConfirmCreateResponse200) & {
  headers: Headers;
};
;

export type bookingsConfirmCreateResponse = (bookingsConfirmCreateResponseSuccess)

export const getBookingsConfirmCreateUrl = (id: string,) => {


  

  return `/api/bookings/${id}/confirm/`
}

export const bookingsConfirmCreate = async (id: string,
    bookingRequest: BookingRequest, options?: RequestInit): Promise<bookingsConfirmCreateResponse> => {
  
  return customFetch<bookingsConfirmCreateResponse>(getBookingsConfirmCreateUrl(id),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      bookingRequest,)
  }
);}




export const getBookingsConfirmCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bookingsConfirmCreate>>, TError,{id: string;data: BookingRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof bookingsConfirmCreate>>, TError,{id: string;data: BookingRequest}, TContext> => {

const mutationKey = ['bookingsConfirmCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof bookingsConfirmCreate>>, {id: string;data: BookingRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  bookingsConfirmCreate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BookingsConfirmCreateMutationResult = NonNullable<Awaited<ReturnType<typeof bookingsConfirmCreate>>>
    export type BookingsConfirmCreateMutationBody = BookingRequest
    export type BookingsConfirmCreateMutationError = unknown

    /**
 * @summary Confirm a booking
 */
export const useBookingsConfirmCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bookingsConfirmCreate>>, TError,{id: string;data: BookingRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof bookingsConfirmCreate>>,
        TError,
        {id: string;data: BookingRequest},
        TContext
      > => {

      const mutationOptions = getBookingsConfirmCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    